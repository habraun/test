#==
Underlying geomtrical structure of the momentum space resolution. The function
symhexagon generates the grid for the bosonic exchange momenta. It is generated by
creating a triangle which is then mirrored and rotated such that the indices of the
momenta are accordingly to these symmetry relations. The first N/12 momenta are the
momenta generated by the triangle. The next N/12 momenta are the mirrored momenta with
respect to the x-axis. The last patches are generated by rotating the existing points with
2*pi/6 5 times.

THe weighter function uses the equidistant points of the hexagon function to calculate
the integration weights of the momenta generated by symhexagon
==#



@everywhere function rot(
    phi ::Float64
    )   ::SArray{Tuple{2,2},Float64,2,4}

    m = @SMatrix [ cos(phi)  -sin(phi) ;
                    sin(phi)  cos(phi) ]

    return m
end

@everywhere function mirror(
    phi::Float64
    ) ::SArray{Tuple{2,2},Float64,2,4}
    m = rot(phi)*[1 0; 0 -1]*rot(-phi)
    return m
end


@everywhere function boxcheck(
    kx::Float64,
    ky::Float64,
    )::Int64

    b=0

    mtest=-(1.0/sqrt(3))
    xlim=2*pi/3
    ylim=4*pi/(sqrt(3)*3)

    if (abs(kx)<=xlim)&(abs(ky)<=ylim)
        mi=( ( (2*pi/(3*sqrt(3))) - abs(ky)  )/( (2*pi/3) - abs(kx) + 1e-18))
        if mi>mtest
            b+=1
        end
    end

    return b
end

@everywhere function hexagon(
    M ::Int64,
    ) ::Array{SArray{Tuple{2},Float64,1,2},1}

    #vecs=[]
    vecs=[]
    #Genereal Grid
    delta=0.5

    dx=(2*pi/3)*2+2*delta
    dy=(8*pi/(3*sqrt(3)))+2*delta

    for m in 0:M*6
        for n in 0:M*6
            #q=(m/M)*[2*2*pi/3,0] + (n/M)*[0,8*pi/(3*sqrt(3))] + [-2*pi/3,-4*pi/(sqrt(3)*3)]
            q=(m/M)*[1.0,0.0] + (n/M)*[0.0,1.0] + [-2*pi/3-delta,-4*pi/(sqrt(3)*3)-delta]
            #push!(vecs,SVector(q[1],q[2]))
            if boxcheck(q[1],q[2])==1
                push!(vecs,SVector(q[1],q[2]))
            end

        end
    end

    return unique(vecs)
end

@everywhere function triangle(
    M           ::Int64,
    Gammapoint  ::Bool,
    Mpoint      ::Bool,
    Kpoint     ::Bool
    )

    vecs=[]
    delta=0.000000000001
    r0=[2*delta,delta]
    Mvec=[2.0*pi/3,0.0]
    Kvec=[1.0,1.0/sqrt(3.0)].*2.0*pi/3.0

    a=(Mvec)-[delta,0.0]
    b=(Kvec)-[delta,4*delta]
    c=b-a


    for m in 0:M
        for n in 0:m
            q=(m/M)*a+(n/M)*c + r0
            push!(vecs,q)
        end
    end

    if Mpoint==true
        a1=-0.25*a/M
        c1=0.25*c/M

        amount=3

        for m in 0:amount
            for n in 0:amount
                if (m+n)==0
                    #nothing
                else
                    q=a+r0+((m/amount)*a1 + (n/amount)*c1).*0.5
                    push!(vecs,q)
                end
            end
        end
    end

    if Kpoint==true
        a1=0.25*a/M
        b1=-0.25*b/M
        amount=6
        for m in 0:amount
            for n in 0:m
                if (m+n)==0
                    #nothing
                elseif (m==amount)&(n==0)
                    #nothing
                elseif (m==amount)&(n==amount)
                    #nothing
                else
                    q=b +(m/amount)*b1 + (n/amount)*a1 +r0
                    push!(vecs,q)
                end
            end
        end
    end



    if Gammapoint==true
        a1=0.25*a/M
        c1=0.25*c/M
        amount=3
        for m in 0:amount
            for n in 0:m
                if (m+n)==0
                    #nothing
                else
                    q=(m/(amount))*a1 + (n/(amount))*c1 +r0
                    push!(vecs,q.*0.5)
                end
            end
        end
    end

    return (vecs)
end


@everywhere function symhexagon(
    M           ::Int64,
    Gammapoint  ::Bool,
    Mpoint      ::Bool,
    Kpoint     ::Bool
    )           ::Array{SArray{Tuple{2},Float64,1,2},1}

    vecs=[]
    vecs_hexagon=triangle(M,Gammapoint,Mpoint,Kpoint)

    for i in 1:length(vecs_hexagon)
        push!(vecs,vecs_hexagon[i])
    end

    for i in 1:length(vecs_hexagon)
        v=vecs_hexagon[i]
        v=[v[1],-v[2]]
        push!(vecs,v)
    end


    for i in 1:5
        for j in 1:length(vecs_hexagon)*2
            q=rot((2.0*pi/6.0)*i)*vecs[j]

            push!(vecs,q)
        end
    end


    vecsreturn=[]
    for i in 1:length(vecs)
        #vecsreturn=[SVector(q[1],q[2]) for q in vecs3]
        q=vecs[i]
        push!(vecsreturn,SVector(q[1],q[2]))
    end


    return vecsreturn
end




##############################WEIGHTER FUNCTION#################################


@everywhere function weighter(
    v::Array,
    p::Int64
    )::Array{Float64,1}

    v2=hexagon(p)
    weight=zeros(length(v))
    println("calc weights")
    kk=1
    for i in 1:length(v2)

        vdist=[vi-v2[i] for vi in v]
        vdist=[sum(vd.*vd) for vd in vdist]
        k=findmin(vdist)
        weight[k[2]]+=1

        if mod(i, Int64(floor(length(v2)/10.0)))==0
            print("|="*string(kk) )
            kk=kk+1
        end

    end

    weight=  round.(weight./(length(v2)),sigdigits=5)
    #for i in Int64(1+length(v)/4):length(v)
    #    weight[i]=weight[i-Int64(length(v)/4)]
    #end

    return weight./sum(weight)

end
